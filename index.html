<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Web book programming</title>
  </head>
  <body>
    <main dir="rtl">
      <section>
        <section>
          <h2>فصل سوم</h2>
          <h3>CSS چیست؟</h3>
          <p>
            مانند HTML، CSS یک زبان برنامه نویسی نیست.این زبان نشانه گذاری نیز
            نیست. CSS یک زبان شیوه نامه است.<br />
            CSS چیزی است که شما برای استایل کردن انتخابی عناصر HTML استفاده می
            کنید. به عنوان مثال، این CSS متن پاراگراف را انتخاب می کند و رنگ را
            قرمز می کند:
          </p>
          <img src="images/3.1 photo.png" />
          <p>
            CSS مخفف Cascading Style Sheets است و زبانی است که برای طراحی سبک و
            چیدمان صفحات وب ایجاد شده با HTML استفاده می شود. <br />در حالی که
            HTML ساختار یک وب سایت را تعریف می کند، CSS از استایل و طرح بندی
            مراقبت می کند - صفحه چگونه باید به نظر برسد. CSS به شما امکان می
            دهد<br />
            رنگ ها، فونت ها، فاصله ها، اندازه ها و موارد دیگر را برای عناصر مختلف
            در یک صفحه وب تعریف کنید.
          </p>
        </section>
    
        <section>
          <h3>درک عمیق‌تر ساختار و اصطلاحات قواعد CSS:</h3>
          <p>
            بیایید کد CSS را برای متن پاراگراف قرمز تجزیه کنیم تا بفهمیم چگونه
            کار می کند؟<br />
            برای تسلط بر CSS و ساختار آن، بررسی دقیق اجزاء و اصطلاحات یک قاعده
            (به انگلیسی "ruleset") ضروری است.<br />
            هر قاعده از چند بخش کلیدی تشکیل شده است که با هم برای اعمال ‍سبک و
            قالب‌بندی به عناصر HTML همکاری می‌کنند.
          </p>
          <img src="images/3.2 photo.png" />

          <p>
            <ul>
            <b>اجزای یک قاعده: </b><br /><br />
            1.انتخابگر / Selector: مشخص می‌کند که کدام عناصر HTML تحت تاثیر
            قاعده قرار می‌گیرند. در ابتدای قاعده قرار دارد و می‌تواند به انواع
            مختلفی از عناصر اشاره کند: انتخابگر نوع / Type selector: مانند p
            برای پاراگراف‌ها
          </p>

          <p>
            انتخابگر کلاس / Class selector: مانند .نام‌کلاس که تمام عناصر با
            کلاس نام‌کلاس را انتخاب می‌کند<br />
            انتخابگر شناسه / ID selector: مانند #نام_شناسه که عنصری با شناسه
            نام_شناسه را انتخاب می‌کند<br />
            شبه‌کلاس‌ها و شبه‌عناصر / Pseudo-class selector: مانند :hover برای
            اثر هاور موس Descendant Selector: عنصری را انتخاب می کند که از نسل
            دیگری است (به عنوان مثال، div p).<br />
            Child Selector: عناصر مستقیم فرزندان را انتخاب می کند (به عنوان
            مثال، ul > li). Adjacent Sibling Selector: عنصری را انتخاب می کند که
            مستقیماً بعد از یک عنصر خاص دیگر قرار دارد (به عنوان مثال، h1 +
            p).<br />
            General Sibling Selector: عناصری را انتخاب می کند که خواهر و برادر
            یک عنصر مشخص شده باشند (به عنوان مثال، h1 ~ p).
            <br /><br />
            <li>2.شبه طبقات / Pseudo-Classes  <br />کلاس ها برای تعریف حالت
            خاصی از یک عنصر استفاده می شوند. در اینجا برخی از رایج ترین کلاس های
            شبه استفاده می شود:<br />
            _:hover: هنگامی که کاربر ماوس را روی یک عنصر با ماوس قرار می دهد،
            استایل ها را اعمال می کند.<br />
            _:focus: هنگامی که یک عنصر فوکوس داشته باشد، سبک‌ها را اعمال می‌کند
            (به عنوان مثال، فیلدهای ورودی هنگام کلیک کردن).<br />
            _:active: هنگامی که یک عنصر فعال می شود (به عنوان مثال، کلیک می شود)
            سبک ها را اعمال می کند.<br />
            _:first-child: اولین فرزند والدین خود را هدف قرار می دهد.<br />
            _:last-child: آخرین فرزند والدین خود را هدف قرار می دهد.<br />
            _:nth-child(n): نهمین فرزند والدین خود را هدف قرار می دهد. </li><br /><br />
            <li>3.شبه عناصر / Pseudo-Elements<br />
            عناصر شبه به شما این امکان را می دهند که به بخش های خاصی از یک عنصر
            استایل دهید. برخی از شبه عناصر رایج عبارتند از:<br />
            ::before: محتوا را قبل از محتوای عنصر انتخاب شده درج می کند.<br />
            ::after: محتوا را بعد از محتوای عنصر انتخاب شده درج می کند.<br />
            ::first-line: خط اول متن یک عنصر را هدف قرار می دهد.<br />
            ::first-letter: حرف اول متن را در یک عنصر هدف قرار می دهد.</li><br /><br />

            <li>4.ترکیب انتخابگرها / Combining Selectors <br />
            می توانید انتخابگرها را برای هدف قرار دادن عناصر به طور خاص تر ترکیب
            کنید، که این امکان را برای الگوهای یک ظاهر پیچیده بدون افزودن کلاس
            ها یا شناسه های اضافی به HTML فراهم می کند:<br />
            _ترکیب یک کلاس و کلاس شبه: .button:hover — هنگامی که ماوس را روی
            عناصر با کلاس "دکمه" قرار می دهید، سبک ها را اعمال می کند.<br />
            _ترکیب شناسه و شبه عنصر: #header::after — محتوا یا سبک‌هایی را بعد
            از محتوای عنصر با شناسه «هدر» اضافه می‌کند.<br /><br />
            این مفاهیم CSS برای طراحی موثر وب یکپارچه هستند و به شما امکان می
            دهند ارائه صفحات وب را به صورت پویا و تعاملی دستکاری کنید و تجربه
            کاربری غنی تری را ارائه دهید. درک این انتخابگرها و شبه عناصر برای
            اعمال دقیق و کارآمد استایل ها ضروری است.<br />

            انتخابگرهای زیادی برای کشف وجود دارد. برای کسب اطلاعات بیشتر،
            راهنمای انتخابگرهای MDN را ببینید:<br />
            https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors
        </li><br />
            <br />
            <li>5.اعلامیه / Declaration:<br />
            یک قانون سبک است که نحوه نمایش عناصر انتخاب‌شده را مشخص می‌کند.<br />
            یک قانون سبک است که نحوه نمایش عناصر انتخاب‌شده را مشخص می‌کند.<br />
            ویژگی / Property: مشخصه عنصر که ‍سبک‌بندی می‌شود (مانند رنگ، ‍فونت،
            چیدمان)<br />
            مقدار / Value: ‍ظاهر یا رفتار ‍ویژگی را تعیین می‌کند (مانند قرمز،
            16px، flexbox)<br />
            مثال: color: red; font-size: 16px </li><br />
            <li>6.ویژگی‌ها / Properties<br />
            مشخصه‌های قابل ‍سبک‌بندی یک عنصر را تعریف می‌کنند.<br />
            CSS ‍ویژگی‌های متنوعی برای ‍تأثیرگذاری بر بخش‌های مختلف ‍یک عنصر
            ارائه می‌دهد:<br />
            تایپوگرافی: مانند font-family, font-size, text-align<br />
            رنگ: مانند color, background-color<br />
            چیدمان: مانند display, float, margin<br />
            موقعیت: مانند position, top, left<br />
            انیمیشن: مانند transition, animation </li><br />
            <li>7.مقدار ‍ویژگی / Property value 
            ‍ظاهر یا رفتار ‍مشخص ‍ویژگی را تعیین می‌کند.<br />
            انواع ‍مقادیر:<br />
            کلمات کلیدی: مانند bold, inherit<br />
            اعداد: مانند 16px, 100%<br />
            رنگ‌ها: مانند red, #00FF00<br />
            طول‌ها: مانند 1em, 20px<br />
            ‍مقادیر ‍پیچیده‌تر: مانند url(image.png), linear-gradient()</li></br>
        <li>قواعد ‍مهم نگارشی / Syntax rules:
        
        پرانتز: قواعد ‍در ‍پرانتزهای مجعد ({}) قرار می‌گیرند.<br>
        دو نقطه: ‍ویژگی و ‍مقدار را در ‍اعلامیه‌ها از هم جدا می‌کند (:).<br>
        نقطه ویرگول: ‍هر ‍اعلامیه را ‍به ‍پایان می‌‍رساند (;).<br>
        ترکیب: ‍امکان ‍استفاده از ‍چند ‍اعلامیه در ‍یک ‍قاعده ‍وجود دارد
        مثال ‍یک ‍قاعده ‍کامل:<br>
        <img src="images/3.3 photo.png"><br>
       </li>

        <li>‍جمع‌بندی:
        قواعد ‍CSS ‍امکان ‍سبک‌بندی ‍عناصر ‍HTML را ‍فراهم ‍می‌کنند.<br>
      ‍انتخابگرها ‍عناصر ‍را ‍انتخاب ‍و ‍اعلامیه‌ها ‍سبک ‍آنها ‍را ‍مشخص ‍می‌کنند.<br>
      ‍ویژگی‌ها و ‍مقادیر ‍جزئیات ‍‍سبک‌<br>
      CSS یک زبان قدرتمند است که برای استایل دادن به اسناد HTML استفاده می شود. دستورات آن، که معمولاً به عنوان خصوصیات شناخته می شوند، می توانند به طور کلی به چندین گروه مفید طبقه بندی شوند. در اینجا برخی از متداول‌ترین ویژگی‌های CSS که بر اساس عملکرد آنها گروه‌بندی شده‌اند، آورده شده است:
       </li></p>
     </ul>
        </section>
        <section>
            <h3>1.ویژگی های طرح بندی / Layout Properties</h3>
            <p>این ویژگی ها به تعریف طرح بندی صفحات وب کمک می کنند.

                نمایش (display): رفتار نمایشگر را مشخص می کند (به عنوان مثال، بلوک، درون خطی، انعطاف پذیر، شبکه).
                موقعیت (position): نوع روش موقعیت یابی مورد استفاده را مشخص می کند (به عنوان مثال، مطلق، نسبی، ثابت، چسبنده).
                Float (float): یک عنصر را در سمت چپ یا راست ظرف آن قرار می دهد و به متن و عناصر درون خطی اجازه می دهد تا دور آن بپیچند.
                Clear (clear): مشخص می کند که عناصر شناور در کدام طرف یک عنصر مجاز به شناور نیستند.
                </p>
        </section>
        <section>
            <h3>Flexbox 2و Grid</h3>
            <p>
                برای ساختارهای چیدمان پیشرفته، به ویژه در طراحی های واکنش گرا استفاده می شود.<br>
ویژگی‌های انعطاف‌پذیری / Flex Properties: شامل جهت انعطاف‌پذیری، انعطاف‌پذیری، توجیه محتوا، تراز کردن آیتم‌ها، تراز کردن محتوا، رشد انعطاف‌پذیر، منقبض شدن انعطاف‌پذیر و پایه انعطاف‌پذیری است.
                ویژگی های گرید: شامل گرید-الگو-ستون ها، گرید-الگو-ردیف ها، گرید-ستون، گرید-ردیف، ناحیه-شبکه، شبکه-شکاف .

            </p>
        </section>
        <section>
            <h3> 3.ویژگی های مدل جعبه  / Box Model Properties</h3>
            <p>اندازه و فاصله عناصر را کنترل کنید.<br>

                Width and Height (width, height): عرض و ارتفاع عناصر را مشخص کنید.
                Padding (padding): فضایی را در اطراف محتوای یک عنصر، در داخل هر مرز تعریف شده ایجاد می کند.
                حاشیه (حاشیه): فضای اطراف عناصر را کنترل می کند.
                Border (border): حاشیه اطراف عناصر را تنظیم می کند.
                </p>
        </section>
        <section>
            <h3>4. خواص تایپوگرافی / Typography Properties</h3>
        <p>این ویژگی ها سبک و طرح متن و فونت ها را مشخص می کنند.<br>

            ویژگی های فونت: شامل اندازه فونت، خانواده فونت، وزن فونت، سبک فونت.
            ویژگی های متن: شامل تراز کردن متن، تزئین متن، تبدیل متن، ارتفاع خط، فاصله حروف، سایه متن.
            </p>
    </section>
        <section>
            <h3>5.ویژگی های جلوه های بصری / Visual Effects Properties</h3>
            <p>علاقه بصری و نشانه‌ها را به طرح‌بندی‌ها اضافه کنید.<br>

                Color (color): رنگ متن را مشخص می کند.
                پس‌زمینه (پس‌زمینه، رنگ پس‌زمینه، تصویر پس‌زمینه، موقعیت پس‌زمینه، پس‌زمینه تکرار، اندازه پس‌زمینه): پس‌زمینه عناصر را تعریف می‌کند.
                Box Shadow (box-shadow): افکت های سایه را در اطراف کادر یک عنصر اضافه می کند.
                Opacity (opacity): سطح کدورت یک عنصر را تنظیم می کند.
                فیلتر (فیلتر): جلوه های گرافیکی مانند تاری یا تغییر رنگ را روی یک عنصر اعمال می کند.
                </p>
        </section>
        <section>
            <h3>6.انیمیشن و انتقال / Animation and Transitions</h3>
            <p>برای افزودن افکت های تعاملی و پویا.

                Transition (transition): راهی برای کنترل سرعت انیمیشن در هنگام تغییر ویژگی های CSS ارائه می دهد.
                انیمیشن (@keyframes، انیمیشن-نام، انیمیشن-مدت، انیمیشن-زمان-عملکرد، انیمیشن-تاخیر، انیمیشن-تکرار-تعداد، انیمیشن-جهت): امکان کنترل بیشتر روی انیمیشن های CSS را فراهم می کند.
                </p>
        </section>
        <section>
            <h3>7.خواص متفرقه / Miscellaneous Properties</h3>
            <p>سایر خواص مهم که اغلب برای اهداف خاص استفاده می شوند.<br>

                مکان نما (cursor): نوع نشانگر ماوس را مشخص می کند.
                Z-index (z-index): ترتیب پشته عناصر همپوشانی را کنترل می کند.
                Visibility (Visibility): مشخص می کند که آیا یک عنصر قابل مشاهده است یا خیر.
                
                این دسته‌بندی‌ها ضروری‌ترین جنبه‌های CSS را پوشش می‌دهند که برای ساخت و استایل تقریباً تمام رابط‌های وب استفاده می‌شوند. هر دسته به بخش خاصی از فرآیند استایل و چیدمان می پردازد و به توسعه دهندگان این امکان را می دهد که هم طراحی های وب جذاب و هم کاربردی ایجاد کنند.
                
                </p>
        </section>
        <section>
            <h3>برخی از مفاهیم اساسی CSS که فراتر از ویژگی ها هستند:
            </h3>
            <ul>
                <li>
                 بیایید این مفاهیم را که شامل انتخابگرها، شبه کلاس‌ها و شبه عناصر و غیره هستند، بررسی کنیم. <br>اینها برای هدف قرار دادن عناصر HTML برای اعمال موثر سبک ها بسیار مهم هستند.
            </li>
            </ul>
               <li>بیایید امتحان کنیم!<br>
                من از این ویرایشگر HTML/CSS برای این پروژه استفاده می کنم:<br>
                https://www.programiz.com/html/online-compiler/
                
                ما روی فایل index.html که در بالا به عنوان مثال ساخته ایم کار می کنیم.
                با استفاده از یک ویرایشگر متن، سه خط CSS (بالا) را در یک فایل جدید قرار دهید. فایل را به عنوان style.css در فهرستی با نام styles ذخیره کنید.<br><br>
                <img src="images/3.4 photo.png"><br>
                اکنون ما سه فایل برای این پروژه داریم: index.html: این همان چیزی است که در فصل 2 HTML ساختیم. (اگر پروژه ما را دنبال نکرده اید، در اینجا مکث کنید تا فصل ۲: Hyper Text Markup Language را بخوانید.)
                iman.png: عکسی است که در مثال خود استفاده می کنیم.<br>
                style.css: ما فقط این را برای استایل های Css خود ایجاد کردیم.<br>
                برای اینکه کد کار کند، همچنان باید این CSS (بالا) را در سند HTML شما اعمال کنیم. در غیر این صورت، استایل ظاهر HTML را تغییر نخواهد داد. 

               فایل index.html خود را باز کنید. خط زیر را در سر (بین تگ‌های <code>&lt;head&gt;</code><code>&lt;/head&gt;</code> ) قرار دهید:<br>
               <img src="images/3.5 photo.png"><br>
               href="در اینجا مسیر فایل style.css می آید" را تغییر دهید!<br><br>
               <li>نتیجه باید اینگونه باشد:</li>
               <img src="images/3.6 photo.png" alt=""><br><br>
               index.html را ذخیره کرده و در مرورگر خود بارگذاری کنید. شما باید چیزی شبیه به این را ببینید:<br>
               اگر متن پاراگراف شما قرمز است، تبریک می‌گوییم! CSS شما کار می کند. اگر نه، لطفا مسیر style.css بالا را بررسی کنید.

             </li>
        </section>
              <ul><li>فونت و متن / Fonts and text</li>
                <p>اکنون که برخی از اصول CSS را بررسی کردیم، بیایید ظاهر مثال را با افزودن قوانین و اطلاعات بیشتر به فایل style.css بهبود دهیم.<br>
                    ابتدا خروجی فونت های گوگل را که قبلاً ذخیره کرده اید از وب سایت شما چگونه خواهد بود پیدا کنید. عنصر <code>&lt;link&gt;</code> را در جایی داخل سر index.html خود اضافه کنید (هر جایی بین تگ‌های <head> و </head>). چیزی شبیه این به نظر می رسد:
                </p><br>
                <img src="images/3.7 photo.png"><br>
                <p>این کد صفحه شما را به یک شیوه نامه پیوند می دهد که خانواده فونت Open Sans را با صفحه وب شما بارگیری می کند.
                    در مرحله بعد، قانون موجود در فایل style.css خود را حذف کنید. تست خوبی بود، اما اجازه دهید با متن قرمز زیاد ادامه ندهیم.
                    خطوط زیر را اضافه کنید (در زیر نشان داده شده است)، و به جای انتساب خانواده فونت با انتخاب خانواده فونت خود از وب سایت شما چه خواهد شد؟ ویژگی font-family به فونت(هایی) که می خواهید برای متن استفاده کنید اشاره دارد. این قانون یک فونت پایه جهانی و اندازه فونت را برای کل صفحه تعریف می کند. از آنجایی که <html> عنصر والد کل صفحه است، همه عناصر داخل آن اندازه فونت و خانواده فونت یکسانی را به ارث می برند.
                    </p><br>
                    <img src="images/3.8 photo.png"><br>
                    <li>توجه: هر چیزی در CSS بین /* و */ یک نظر CSS است. مرورگر هنگام ارائه کد، نظرات را نادیده می گیرد. نظرات CSS راهی برای نوشتن یادداشت های مفید در مورد کد یا منطق خود است.</li><br>
                    <p>حالا بیایید اندازه فونت را برای عناصری که متنی در بدنه HTML دارند (<code>&lt;h1&gt;</code>، <code>&lt;li&gt;</code> ، <code>&lt;p&gt;</code>) تنظیم کنیم. ما همچنین عنوان را در مرکز قرار می دهیم. در نهایت، اجازه دهید مجموعه قوانین دوم (در زیر) را با تنظیمات ارتفاع خط و فاصله حروف گسترش دهیم تا محتوای بدنه را خوانا تر کنیم.
                    </p><br>
                    <img src="images/3.9 photo.png"><br>
                    <p>مقادیر px را همانطور که دوست دارید تنظیم کنید. کار در حال انجام شما باید شبیه به این باشد:
                    </p><br>
                    
              </ul>
        </section>
        <section>
            <ul>
                <h3>CSS: همه چیز درباره جعبه ها Boxes</h3><br>
                <p>چیزی که در مورد نوشتن CSS متوجه خواهید شد: بسیاری از آن در مورد جعبه ها هستند. این شامل تنظیم اندازه، رنگ و موقعیت است. بیشتر عناصر HTML در صفحه شما را می توان به عنوان جعبه هایی در نظر گرفت که در بالای کادرهای دیگر قرار دارند.
                </p><br>
                <img src="images/3.10 photo.png"><br>
                <p>چیدمان CSS بیشتر بر اساس مدل جعبه است. هر کادری که فضای صفحه شما را اشغال می کند دارای ویژگی هایی مانند:
                </p>
                <li>padding، فضای اطراف محتوا. در مثال زیر، فضای اطراف متن پاراگراف است.</li>
                    <li>border، خط ثابتی که درست خارج از بالشتک قرار دارد.</li>
                    <li>margin، فضای اطراف بیرون مرز.</li><br>
                    <img src="images/3.11 photo.png"><br>
                    <p>در این بخش نیز از:</p><br>
                    <li>
                        width : عرض (یک عنصر).
                   </li>
                   <li> background color پس‌زمینه رنگ، رنگ پشت محتوای یک عنصر و بالشتک.
                </li>
                <li>color  رنگ، رنگ محتوای یک عنصر (معمولاً متن).
                </li>
                <li> text-shadow بر روی متن داخل یک عنصر سایه می گذارد.</li>
                <li> display حالت نمایش یک عنصر را تنظیم می کند. (برای یادگیری بیشتر خواندن را ادامه دهید)
                </li><br>
                <p>برای ادامه، بیایید CSS بیشتری اضافه کنیم. به افزودن این قوانین جدید در پایین style.css ادامه دهید. با تغییر مقادیر آزمایش کنید تا ببینید چه اتفاقی می افتد.
                </p><br>
            </ul>
        </section>
        <section>
            <ul>
                <h3>
                    تغییر رنگ صفحه
                </h3>
                <p>این قانون یک رنگ پس زمینه برای کل صفحه تعیین می کند. کد رنگ را به رنگی که انتخاب میکنید تغییر دهید:
                </p><br>
                <img src="images/3.12 photo.png"><br>

            </ul>
        </section>
        <section>
            <ul>
                <h3>حالت دادن به بدن / Styling the body</h3>
                <p>ین کد را به فایل style.css اضافه کنید:</p><br>
                <img src="images/3.13 photo.png"><br>
                <p>توضیحات برای عنصر <code>&lt;body&gt;</code>
                    برخی از اعلان‌هایی که معمولاً برای عنصر <code>&lt;body&gt;</code> استفاده می‌شوند به شرح زیر هستند. اجازه بدید آن‌ها را خط به خط بررسی کنیم:<br>
                        
                    </p>
                    <li>width: 600px 
                        این کد عرض عنصر <code>&lt;body&gt;</code> را همیشه 600 پیکسل ثابت نگه می‌دارد.
                        </li>
                        <li>margin: 0 auto
                            زمانی که برای ویژگی‌ای مانند margin یا padding دو مقدار اختصاص می‌دهید، مقدار اول بر بالا و پایین عنصر تأثیر می‌گذارد (که در این مورد مقدار آن صفر در نظر گرفته شده است). مقدار دوم بر چپ و راست عنصر اثر می‌گذارد. auto در اینجا یک مقدار ویژه است که فضای افقی باقی‌مانده را به‌طور مساوی بین چپ و راست تقسیم می‌کند. به یاد داشته باشید که می‌توانید از یک، دو، سه یا چهار مقدار با توجه به مستندات "Margin Syntax" استفاده کنید.
                            </li>
                            <li>background-color: #FFFFFF
                                رنگ پس‌زمینه عنصر را تنظیم می‌کند. در اینجا یک رنگ نارنجی مایل به قرمز برای پس‌زمینه <code>&lt;body&gt;</code> در نظر گرفته شده است. این در تقابل با رنگ آبی تیره استفاده‌شده برای پس‌زمینه عنصر <code>&lt;html&gt;</code> است. (می‌توانید با رنگ‌ها به دلخواه خودتان آزمایش کنید.)
                                </li>
                                <li>padding: 0 20px 20px 20px
                                    چهار مقدار برای حاشیه‌گذاری داخلی تعیین می‌کند. هدف از این کد افزودن فاصله در اطراف محتوایِ درون عنصر است. در این مثال، در بالای <code>&lt;body&gt;</code> حاشیه‌ای وجود ندارد و 20 پیکسل فاصله در سمت راست، پایین و چپ آن در نظر گرفته شده است. مقادیر به‌ترتیب "بالا، راست، پایین و چپ" لحاظ می‌شوند. همانند margin ، می‌توانید از یک، دو، سه یا چهار مقدار طبق آنچه در "Padding Syntax" توضیح داده شده است استفاده کنید.
                                    </li>
                                    <li>border: 5px solid black
                                        مقادیر عرض، سبک و رنگ حاشیه خارجی عنصر را مشخص می‌کند. در اینجا نوع حاشیه solid و به‌رنگ مشکی و با عرض 5 پیکسل در نظر گرفته شده است که در تمام اضلاع <code>&lt;body&gt;</code> لحاظ می‌شود.
                                        اگر همه چیز را به درستی انجام داده اید، اکنون وب سایت باید به این شکل باشد
                                        </li>
            </ul>
        </section>
        <section>
            <ul>
                <h3>تعیین موقعیت و استایل کردن عنوان صفحه اصلی</h3><br>
                <img src="images/3.14 photo.png"><br>
                <p>ممکن است متوجه شده باشید که شکاف وحشتناکی در بالای بدن وجود دارد. این اتفاق می افتد زیرا مرورگرها یک ظاهر طراحی پیش فرض را برای عنصر h1 (در میان سایر موارد) اعمال می کنند. ممکن است ایده بدی به نظر برسد، اما هدف این است که خوانایی اولیه برای صفحات بدون استایل ارائه شود. برای از بین بردن شکاف، استایل پیش فرض مرورگر را با حاشیه تنظیم بازنویسی می کنیم:
                </p>

                <ol>;margin: 0
                    <p>در مرحله بعد، قسمت بالا و پایین عنوان را روی 20 پیکسل قرار می دهیم.<br>
                        به دنبال آن، متن عنوان را همرنگ رنگ پس‌زمینه HTML قرار می‌دهیم.<br>
                        در نهایت، text-shadow یک سایه به محتوای متن عنصر اعمال می کند. چهار مقدار آن عبارتند از:
                        </p>
                    <li> اولین مقدار پیکسل، افست افقی سایه را از متن تعیین می کند: تا چه اندازه حرکت کند.</li>
                    <li> دومین مقدار پیکسل، افست عمودی سایه را از متن تعیین می کند: چقدر به سمت پایین حرکت کند.
                    </li>
                    <li>  سومین مقدار پیکسل شعاع تاری سایه را تعیین می کند. یک مقدار بزرگتر باعث ایجاد سایه مبهم تری می شود.
                    </li>
                    <li>    مقدار چهارم رنگ پایه سایه را تعیین می کند.
                    </li>
                </ol>
                <p>سعی کنید با مقادیر مختلف آزمایش کنید تا ببینید چگونه ظاهر را تغییر می دهد.</p>
            </ul>
        </section>
        <section>
            <ul>
                <h3>مکان تصویر را تغییر دهید / Change the image position</h3><br>
                <img src="images/3.15 photo.png">
                <p>در مرحله بعد، تصویر را در مرکز قرار می دهیم تا بهتر به نظر برسد. <br>می‌توانیم از حاشیه استفاده کنیم: 0 ترفند خودکار دوباره همانطور که برای بدنه انجام دادیم. اما تفاوت هایی وجود دارد که برای کارکرد CSS نیاز به تنظیمات اضافی دارد.<br>
                    <body> یک عنصر بلوک است، به این معنی که فضای صفحه را اشغال می کند. حاشیه اعمال شده بر روی یک عنصر بلوک توسط سایر عناصر موجود در صفحه رعایت می شود. در مقابل، تصاویر عناصر درون خطی هستند، برای اینکه ترفند حاشیه خودکار روی این تصویر کار کند، باید با استفاده از ;display: block رفتاری در سطح بلوک به آن بدهیم.</p>
            <li>توجه: دستورالعمل‌های بالا فرض می‌کنند که از تصویری کوچک‌تر از عرض تنظیم‌شده روی بدنه استفاده می‌کنید. (600 پیکسل) اگر تصویر شما بزرگتر باشد، از بدنه سرریز می شود و به بقیه صفحه می ریزد. برای رفع این مشکل، می توانید: 1<br> (عرض تصویر را با استفاده از ویرایشگر گرافیکی کاهش دهید، یا 2) از CSS برای اندازه گیری تصویر با تنظیم ویژگی width در عنصر <code>&lt;img&gt;</code> با مقدار کوچکتر استفاده کنید.

                توجه: اگر کاملاً متوجه نشدید، زیاد نگران نباشید: block; یا تفاوت بین یک عنصر بلوکی و یک عنصر درون خطی. با ادامه مطالعه CSS، منطقی تر خواهد بود. می توانید اطلاعات بیشتری در مورد مقادیر مختلف نمایش در صفحه مرجع نمایشگر MDN بیابید.
                https://developer.mozilla.org/en-US/docs/Web/CSS/display
                
                </li>
                <p>اگر تمام دستورالعمل‌های ما را دنبال کردید، باید صفحه‌ای مشابه این صفحه داشته باشید:<br>
                    index.html
                    </p>
                    <img src="images/3.16 photo.png"><br>
                    <p>style.css</p><br>
                    <img src="images/3.17 photo.png"><br>

                    </ul>
        </section>
      </section>

      <section>
        <section>
            <h2>فصل چهارم</h2>
            <h3>API (Application Programming)Interfaces</h3>
            <img src="images/4.1 photo.png " alt=""><br>
            <p>در حوزه توسعه وب، درک رابط های برنامه نویسی کاربردی <br>(API) برای استفاده از پتانسیل کامل جاوا اسکریپت بسیار مهم است.<br> API ها به عنوان پل عمل می کنند و برنامه های وب شما را قادر می سازند تا با سایر برنامه ها، سرویس های وب و سیستم عامل ها تعامل داشته باشند. آنها به عنوان ابزاری عمل می کنند که به توسعه دهندگان اجازه می دهد تا بر اساس عملکرد موجود بدون نیاز به اختراع مجدد چرخ برای هر پروژه جدید، کار کنند.
            </p> 
        </section>
        <section>
            <h3>API ها چیست؟</h3>
            <img src="images/4.2 photo.png" alt=""><br>
            <p>API ها یا Application Programming Interfaces مجموعه ای از پروتکل ها، ابزارها و تعاریف هستند که به نرم افزارهای مختلف اجازه می دهند تا با یکدیگر ارتباط برقرار کنند. آنها توسعه دهندگان را قادر می سازند تا به عملکردهای داخل یا خارج از محیط خود دسترسی داشته باشند بدون اینکه نیازی به درک یا بازسازی آنها از ابتدا داشته باشند. این شبیه به استفاده از اجزای آماده در ساخت و ساز است که به طور قابل توجهی روند ساخت سازه های پیچیده را ساده می کند.</p>
        </section>
        <section>
            <h3>انواع API ها
            </h3><br>
            <img src="images/4.3 photo.png" alt=""><br>
            <p>API ها را می توان بر اساس در دسترس بودن، سطح دسترسی و دامنه عملکردشان دسته بندی کرد. چهار نوع اصلی وب API عبارتند از:</p><br>
            <ul>
                <li>APIهای باز (Public API): اینها برای هر توسعه‌دهنده‌ای برای استفاده با حداقل محدودیت در دسترس هستند. ممکن است رایگان باشند یا نیاز به اشتراک داشته باشند. APIهای باز برای به اشتراک گذاری داده ها و خدمات با جامعه توسعه دهندگان گسترده تر هستند، اما معمولاً دسترسی محدودی به منابع برای اطمینان از امنیت و مدیریت بار ارائه می دهند.</li>
                <li>API های شریک (Partner APIs): همانطور که از نام آن پیداست، API های شریک در معرض شرکای تجاری استراتژیک قرار دارند. آنها به حقوق و مجوزهای خاصی برای دسترسی و ارائه یک محیط کنترل شده برای به اشتراک گذاری داده ها و عملکردهای حساس یا ارزشمندتر نیاز دارند.</li>
                <li>
                    APIهای داخلی (Private API): این APIها که برای استفاده در یک سازمان طراحی شده اند، عملیات را با امکان برقراری ارتباط سیستم ها یا برنامه های مختلف در یک سازمان با یکدیگر ساده می کنند. آنها در معرض عموم قرار نمی گیرند و سطح بالایی از امنیت و کنترل را تضمین می کنند.
                    </li>
                    <li>
                        API های ترکیبی (Composite APIs): ترکیبی از API های مختلف هستند که برای انجام یک کار یا حل یک مشکل پیچیده با هم کار می کنند. APIهای ترکیبی به توسعه‌دهنده اجازه می‌دهند تا چندین تماس API را در یک تماس جمع کند، بار سرور را کاهش دهد، کد مشتری را ساده‌تر کند و عملکرد برنامه را بهبود بخش
                        </li>
            </ul>
        </section>
        <section>
            <h3>معماری API</h3><br>
            <img src="images/4.4 photo.png" alt=""><br>
            <p>چشم انداز دیجیتال مملو از مجموعه ای از رابط های برنامه نویسی کاربردی (API) است که هر کدام به عنوان مجرای حیاتی برای تعامل یکپارچه بین سیستم های نرم افزاری متفاوت عمل می کنند. APIها ستون فقرات توسعه نرم‌افزار مدرن هستند و قابلیت‌هایی را از بازیابی ساده داده تا اجرای فرآیندهای تجاری پیچیده را ممکن می‌سازند. همانطور که ما در دنیای گسترده API ها کاوش می کنیم، درک انواع و تفاوت های معماری آنها برای ایجاد برنامه های کاربردی قوی و کارآمد بسیار مهم است. بیایید معماری های متنوع API و ویژگی های منحصر به فرد آنها را بررسی کنیم و دانش خود را فراتر از اصول اولیه غنی کنیم.

                معماری یک API نحوه برقراری ارتباط، سطح امنیتی که ارائه می دهد، کارایی آن در مدیریت داده ها و سهولت یکپارچه سازی آن را تعیین می کند. از REST و SOAP پرکاربرد گرفته تا GraphQL و gRPC تخصصی، هر معماری جای خود را در جعبه ابزار توسعه دهنده دارد.
                </p>
                <img src="images/4.5 photo.png" alt="">
        </section>
        <section>
            <h3>(SOAP) Simple Object Access Protocol</h3><br>
            <img src="images/4.6 photo.png" alt=""><br>
            <p>SOAP یا Simple Object Access Protocol سنگ بنای دنیای معماری های API است که برای اطمینان از قابلیت همکاری و تبادل یکپارچه داده در سیستم های مختلف طراحی شده است. SOAP با رعایت مجموعه ای از قوانین جهانی، تعامل قابل اعتماد بین برنامه های کاربردی سرویس گیرنده و سرور را بدون توجه به پشته فناوری زیربنایی آنها تسهیل می کند. در اینجا، ما به نکات ضروری SOAP می پردازیم، ویژگی های آن، موارد استفاده، و تعادل مزایا و معایب آن را برجسته می کنیم.
                SOAP بر اساس یک اصل اساسی کار می کند که امکان برقراری ارتباط پایدار بین برنامه های توسعه یافته با زبان ها و پلتفرم های مختلف را فراهم می کند. این پروتکل از پیام‌های مبتنی بر XML که در پاکت‌ها پیچیده شده‌اند برای انتقال اطلاعات درخواست و پاسخ بین کلاینت و سرور استفاده می‌کند. ساختار یک پیام SOAP معمولاً شامل دو بخش اصلی است: هدر که حاوی ابرداده در مورد پیام است و بدنه که داده‌های درخواست یا پاسخ واقعی را در خود نگه می‌دارد.
                </p>
        </section>
        <section>
            <h3>ویژگی های کلیدی SOAP
            </h3>
            <ul>
                <li>مبتنی بر XML: پیام های SOAP در XML ساخته می شوند، یک زبان نشانه گذاری همه کاره که تضمین می کند پیام ها در سیستم های مختلف قابل درک هستند.
                </li>
                <li>پهنای باند فشرده: به دلیل ساختار دقیق پیام، SOAP پهنای باند بیشتری را در مقایسه با سایر سبک‌های API مصرف می‌کند و داده‌های گسترده‌ای را در پیام‌های خود جای می‌دهد.
                </li>
                <li>ناسازگاری با REST :REST و SOAP سبک های معماری متفاوتی هستند که هر کدام رویکرد منحصر به فرد خود را در طراحی و تعامل API دارند. استانداردها و ساختارهای SOAP با اصول RESTful همخوانی ندارند.
                </li>
            </ul>
            <p>چه زمانی از SOAP استفاده کنیم؟
                SOAP در سناریوهایی که سطوح بالایی از امنیت، قابلیت اطمینان و ارتباطات رسمی را می طلبد می درخشد. مناسب بودن آن به برنامه های مختلف گسترش می یابد:
                
                </p><br>
                <ul>
                    <li>عملیات همزمان: ایده آل برای برنامه هایی که نیاز به تبادل داده های قابل اعتماد و پردازش بلادرنگ دارند.</li>
                    <li>ارتباطات رسمی: زمانی که قالب‌های پیام از پیش تعریف‌شده و سخت‌گیرانه برای مبادلات سرور و مشتری ضروری باشد.
                    </li>
                    <li>عملیات Stateful: SOAP از برنامه هایی پشتیبانی می کند که نیاز به حفظ متن یا حالت در چندین درخواست دارند.
                    </li>
                </ul>
                <p>نمونه ای از SOAP API
                    یک مثال پیام SOAP ساختار آن را نشان می‌دهد، از جمله یک اعلان فضای نام، سرصفحه‌های ابرداده و بدنه حاوی درخواست.
                    </p><br>
                    <img src="images/4.7 photo.png" alt="">
        </section>
        <section>
            <h3>مزایا و معایب SOAP</h3><br>
            <p>مزایا:</p>
            <ul>
               <li>یکپارچه سازی WSDL: از زبان توصیف خدمات وب (WSDL) برای مستندسازی دقیق خدمات وب، افزایش مصرف و توسعه API استفاده می کند.
            </li>
            <li>توسعه پذیر: سازگار با افزونه های متعدد (مانند WS-Security، WS-Federation)، ایجاد برنامه های کاربردی بسیار کاربردی و ایمن را تسهیل می کند.
            </li>
            <li>Protocol Agnostic: روی چندین پروتکل حمل و نقل (HTTP، SMTP، TCP) کار می کند و آن را برای موارد استفاده مختلف همه کاره می کند.</li>
            </ul>
            <p>معایب:
            </p><br>
            <ul>
                <li>سربار عملکرد: استفاده از XML برای انتقال داده ها به دلیل ماهیت پرمخاطب آن، نگرانی های عملکردی را ایجاد می کند.</li>
                <li>نحو پیچیده: اتکای SOAP به XML و نحو پیچیده آن می‌تواند استخراج داده‌ها را پیچیده و زمان‌بندی توسعه را طولانی کند.
                </li>
            </ul>
            <p>بی‌طرفی پروتکل، ویژگی‌های امنیتی و پشتیبانی از قابلیت اطمینان تراکنشی SOAP، آن را به گزینه‌ای قوی برای برنامه‌های کاربردی در سطح سازمانی تبدیل می‌کند که در آن این ویژگی‌ها بسیار مهم هستند. با این حال، سربار عملکرد و پیچیدگی نحوی آن نشان می‌دهد که قبل از پذیرش، به‌ویژه برای برنامه‌هایی که کارایی و سادگی در آن‌ها اهمیت دارد، به دقت توجه شود. SOAP یک معماری API محوری باقی می‌ماند که تعادلی بین عملکرد جامع و الزامات یکپارچه‌سازی سیستم پیچیده را در بر می‌گیرد.</p>
        </section>
        <section>
            <h3>(REST) Representational State Transfer</h3>
            <img src="images/4.8 photo.png" alt=""><br>
            <p>REST، مخفف Representational State Transfer، یک رویکرد معماری متمایز را برای طراحی API اتخاذ می کند. این الگویی است که به طور گسترده در برنامه های کاربردی وب مدرن استفاده می شود و روشی انعطاف پذیر و کارآمد برای مدیریت اجزای مختلف برنامه مانند فایل ها، اشیاء و رسانه ها ارائه می دهد. API های REST عملکرد را بر روی HTTP تسهیل می کنند و از افعال HTTP مانند GET و POST برای پشتیبانی از قابلیت همکاری در سراسر وب استفاده می کنند و آنها را به انتخابی ارجح برای بسیاری از توسعه دهندگان تبدیل می کند.</p><br>
            <img src="images/4.9 photo.png" alt="">
        </section>
        <section>
            <h3>موارد استفاده ایده آل برای REST</h3>
            <p>REST ارزش خود را در سناریوهایی ثابت می کند که پهنای باند محدود است، عملیات بدون حالت مورد نیاز است، کش بسیار مهم است، و سرعت توسعه ضروری است:</p>
            <ul>
                <li>پهنای باند محدود: اگر با محدودیت‌های پهنای باند کار می‌کنید، فرمت تبادل داده سبک REST (معمولاً JSON) بسیار کارآمدتر از XML پرمخاطب مورد استفاده در پیام‌های SOAP است.
                </li>
                <li>عملیات بدون حالت: REST برای ارتباطات بدون حالت طراحی شده است، و برای تراکنش هایی که نیازی به یادآوری تعاملات قبلی از سوی سرور ندارند، مناسب است.
                </li>
                <li>حجم بالای درخواست ها: امکان ذخیره درخواست ها با REST نیاز به تماس های مکرر باطن را کاهش می دهد و عملکرد و سرعت توسعه را افزایش می دهد.
                </li>
                <li>سادگی و سرعت در توسعه: رویکرد ساده REST و نگاشت مستقیم به افعال HTTP، فرآیند کدگذاری را ساده می‌کند و چرخه‌های توسعه سریع‌تر را ممکن می‌سازد.
                </li>
            </ul>
            <h4>مزایا و معایب REST:</h4>
            <ul>
                <li>بدون وضعیت: هر تماس API مستقل است، تراکنش ها را سرعت می بخشد و معماری سرور را ساده می کند.
                </li>
                <li>انعطاف‌پذیری فرمت: API‌های REST می‌توانند در قالب‌های مختلف ارتباط برقرار کنند و در نحوه مدیریت و ارائه داده‌ها تطبیق‌پذیری ایجاد کنند.
                </li>
                <li>پشتیبانی از حافظه پنهان: REST ذخیره اطلاعات کارآمد، کاهش درخواست های غیر ضروری سرور و بهبود عملکرد برنامه را امکان پذیر می کند.
                </li>
            </ul>
            <h4>معایب:
            </h4>
            <ul>
                <li>عدم استانداردسازی: بدون استانداردهای پذیرفته شده جهانی، پیاده سازی REST می تواند متفاوت باشد و به طور بالقوه توسعه و یکپارچه سازی API را پیچیده کند.
                </li>
                <li>محدودیت HTTP: همراهی محکم با HTTP می‌تواند REST را در محیط‌هایی که ممکن است پروتکل‌های ارتباطی جایگزین ترجیح داده شوند، محدود کند.

                </li>
            </ul>
        </section>
        <section>
            <h3>روش های REST API و ساختار درخواست</h3>
            <img src="images/4.10 photo.png" alt=""><br>
            <p>هر درخواست REST شامل چهار بخش اساسی است: یک روش HTTP، یک نقطه پایانی، هدرها و یک بدنه.
                یک روش HTTP توصیف می کند که با یک منبع چه کاری باید انجام شود. چهار روش اساسی وجود دارد که عملیات CRUD نیز نامیده می شود:
                </p>
                <ul>
                    <li>POST برای ایجاد یک منبع پست کنید،</li>
                    <li>Get دریافت یک منبع،</li>
                    <li>PUT  قرار دادن برای به روز رسانی یک منبع، و
                    </li>
                    <li>DELETE برای حذف یک منبع.</li>
                </ul>
                <p>یک نقطه پایانی (Endpoint) حاوی یک شناسه منبع یکنواخت (URI) است که نشان می دهد کجا و چگونه منبع را در اینترنت پیدا کنید. متداول ترین نوع URI یک مکان منبع منحصر به فرد (URL) است که به عنوان یک آدرس وب کامل عمل می کند.
                    هدرها (Headers) اطلاعات مربوط به مشتری و سرور را ذخیره می کنند. به طور عمده، هدرها داده‌های احراز هویت را ارائه می‌کنند - مانند یک کلید API، نام یا آدرس IP رایانه‌ای که سرور در آن نصب شده است، و اطلاعات مربوط به فرمت پاسخ.
                    یک بدنه (Body) برای انتقال اطلاعات اضافی به سرور استفاده می شود. به عنوان مثال، ممکن است بخشی از داده باشد که می خواهید اضافه یا جایگزین کنید.
                    </p>
        </section>
        <section>
            <h3>ساختار پاسخ REST</h3><br>
            <img src="images/4.11 photo.png" alt=""><br>
            <p>در پاسخ، سرور نه خود منبع مورد نظر، بلکه نمایش آن را می فرستد - یک توصیف قابل خواندن توسط ماشین از وضعیت فعلی آن. یک منبع را می توان در قالب های مختلف نشان داد، اما محبوب ترین آنها XML و JSON هستند.


                هر زمان که مرتبط باشد، یک سرور در پاسخ، هایپرلینک ها یا ابررسانه هایی را که به منابع مرتبط دیگر پیوند می دهند، شامل می شود. به این ترتیب، سرور دستورالعمل هایی را در مورد کارهای بعدی که مشتری می تواند انجام دهد و درخواست های بعدی را ارائه می دهد.
                </p>
            <ul>
                <li>نمونه ای از تماس REST API
                </li>
                <li>سناریویی را در نظر بگیرید که در آن باید جزئیات یک کاربر را با استفاده از REST API فچ (فچ کردن) کنید. عملیات را می توان به صورت زیر ساختار داد:
                </li>
            </ul>
            <p>Request:</p><br>
            <img src="images/4.12 photo.png" alt=""><br>
            <p>Response:</p><br>
            <img src="images/4.13 photo.png" alt=""><br>
            <p>این مثال یک تماس REST API را نشان می‌دهد که در آن مشتری جزئیات کاربر را با یک درخواست GET درخواست می‌کند و سرور با اطلاعات کاربر در قالب JSON پاسخ می‌دهد.
            </p>
        </section>
        <section>
            <h3>REST در مقابل SOAP: ملاحظات عملکرد</h3><br>
            <img src="images/4.14 photo.png" alt=""><br>
            <p>REST اغلب از نظر سرعت و کارایی از SOAP پیشی می‌گیرد، زیرا ماهیت کمتر دست و پا گیر آن، اتکا به JSON (که معمولاً سبک‌تر از XML است) و توانایی آن در کش کردن داده‌ها. SOAP با مشخصات سختگیرانه و ویژگی های امنیتی خود، ذاتاً پیچیده تر و پرمخاطب تر است که منجر به استفاده از پهنای باند بیشتر و عملکرد کندتر در سناریوهایی می شود که REST می تواند کافی باشد.

                به طور خلاصه، APIهای REST یک رویکرد انعطاف‌پذیر، کارآمد و توسعه‌دهنده را برای ساخت سرویس‌های وب ارائه می‌کنند، به خصوص زمانی که عملکرد، سادگی و سرعت بسیار مهم هستند. توانایی آنها برای کار بر روی HTTP، پشتیبانی از فرمت های مختلف داده، و ارتباطات بدون حالت، آنها را برای طیف گسترده ای از برنامه های کاربردی وب مناسب می کند. با این حال، درک زمان و مکان استفاده از REST، بر خلاف معماری های دیگر مانند SOAP، کلیدی برای استفاده از پتانسیل کامل آن است.
                </p>
        </section>
        <section>
            <h3>GraphQL
            </h3><br>
            <img src="images/4.15 photo.png" alt=""><br>
            <p>GraphQL به عنوان یک رویکرد دگرگون کننده در عرصه توسعه API است و یک زبان پرس و جو را در کنار یک زمان اجرا سمت سرور برای اجرای آن کوئری ها با استفاده از نوع سیستمی که برای داده های خود تعریف می کنید، ارائه می دهد. برخلاف روش‌های سنتی که در آن سرور ساختار داده‌ها را دیکته می‌کند، GraphQL به مشتریان این امکان را می‌دهد که دقیقاً آنچه را که نیاز دارند درخواست کنند، فچ کردن داده‌ها را کارآمدتر می‌کند و مسائل مربوط به فچ بیش از حد یا کم فچ را کاهش می‌دهد.</p><br>
            <p>GraphQL به عنوان یک رویکرد دگرگون کننده در عرصه توسعه API است و یک زبان پرس و جو را در کنار یک زمان اجرا سمت سرور برای اجرای آن کوئری ها با استفاده از نوع سیستمی که برای داده های خود تعریف می کنید، ارائه می دهد. برخلاف روش‌های سنتی که در آن سرور ساختار داده‌ها را دیکته می‌کند، GraphQL به مشتریان این امکان را می‌دهد که دقیقاً آنچه را که نیاز دارند درخواست کنند، فچ کردن داده‌ها را کارآمدتر می‌کند و مسائل مربوط به فچ بیش از حد یا کم فچ را کاهش می‌دهد.</p>
        </section>
        <section>
            <h3>تشخیص GraphQL از REST</h3><br>
            <img src="images/4.16 photo.png" alt=""><br>
            <p>در حالی که REST یک استاندارد دیرینه برای APIهای وب بوده است و از روش‌های HTTP برای مدیریت منابع استفاده می‌کند، اغلب منجر به فچ کردن بیش از حد یا کمتر از حد داده‌ها می‌شود و به‌روزرسانی‌های بلادرنگ را به طور موثر پشتیبانی نمی‌کند. GraphQL این کاستی ها را با ارائه موارد زیر برطرف می کند:
            </p>
            <ul>
                <li>یک نقطه پایانی واحد برای پرس و جوها، اجتناب از نیاز به درخواست های متعدد برای داده ها از منابع مختلف.
                </li>
                <li>توانایی مشخص کردن دقیقاً چه داده‌هایی در یک درخواست مورد نیاز است، در نتیجه فچ کردن بیش از حد یا کم فچ  را حذف می‌کند.
                </li>
                <li>پشتیبانی از به روز رسانی داده ها در زمان واقعی از طریق اشتراک، افزایش ماهیت پویا برنامه های وب.
                </li>
            </ul>
        </section>
        <section>
            <h3>مفاهیم کلیدی در GraphQL
            </h3><br>
            <p>نوع سیستم: اساس GraphQL سیستم نوع قوی آن است که امکان تعریف انواع سفارشی در کنار انواع داخلی مانند Int، Float و String را فراهم می کند. به عنوان مثال، تعریف یک نوع کاربر ممکن است به شکل زیر باشد:
            </p><br>
            <img src="images/4.17 photo.png" alt=""><br>
            <p>Schema: طرحواره ای که با استفاده از زبان تعریف طرحواره (SDL) تعریف شده است، ساختار داده های موجود از طریق GraphQL API شامل انواع شی، فیلدها و روابط آنها را مشخص می کند.

                Resolvers: این توابع هر فیلد در یک جستار GraphQL را به یک منبع داده متصل می کنند و اطمینان می دهند که داده های صحیح در پاسخ به پرس و جوها فچ  شده و برگردانده می شوند.
                </p><br>
                <p>کوئری ها و جهش ها / Queries and Mutations: کوئری ها در GraphQL داده ها را بازیابی می کنند (مشابه درخواست GET REST)، در حالی که جهش ها داده ها را تغییر می دهند (شبیه به POST، PUT، PATCH، DELETE در REST). یک درخواست برای فچ  جزئیات کاربر ممکن است به شکل زیر باشد:
                </p><br>
                <img src="images/4.18 photo.png" alt=""><br>
                <p>اشتراک‌ها / Subscriptions: اشتراک‌ها مکانیزمی برای به‌روزرسانی‌های بی‌درنگ فراهم می‌کنند و به مشتریان این امکان را می‌دهند که داده‌های جدید را به‌محض در دسترس بودن بدون نیاز به نظرسنجی دریافت کنند.
                </p><br>
                <h4>مزایای استفاده از GraphQL</h4>
                <ul>
                    <li>انعطاف پذیری و کارایی: مشتریان می توانند داده ها را از منابع متعدد در یک درخواست فچ  کنند و دقیقاً آنچه را که نیاز دارند مشخص کنند.
                    </li>
                    <li>Evolution Without Versioning: فیلدها و انواع جدیدی را می توان بدون تأثیر بر پرس و جوهای موجود به API اضافه کرد.</li>
                    <li>تایپ قوی: سیستم مبتنی بر طرحواره و با تایپ قوی، تشخیص زودهنگام خطاها را تسهیل می کند و از تولید خودکار اسناد پشتیبانی می کند.
                    </li>
                    <li>داده‌های بی‌درنگ با اشتراک‌ها: عملکرد بی‌درنگ در GraphQL تعبیه شده است، و آن را برای برنامه‌هایی که نیاز به به‌روزرسانی فوری داده دارند، ایده‌آل می‌کند.
                    </li>
                </ul>
                <h4>چالش ها و ملاحظات</h4>
                <ul>
                    <li>پیچیدگی: پیاده سازی GraphQL API می تواند پیچیدگی را در سمت سرور ایجاد کند که نیاز به طراحی و نگهداری دقیق دارد.
                    </li>
                    <li>منحنی یادگیری: توسعه دهندگان ممکن است به دلیل رویکرد منحصر به فرد GraphQL در مقایسه با API های سنتی REST با منحنی یادگیری مواجه شوند.
                    </li>
                    <li>امنیت: برای جلوگیری از سوء استفاده از انعطاف پذیری GraphQL پرس و جوهای مخرب باید اقدامات مناسبی انجام شود.
                    </li>
                </ul>
        </section>
        <section>
            <h3>ساخت GraphQL API</h3><br>
            <p>ایجاد یک GraphQL API شامل تعریف یک طرحواره، راه‌اندازی حل‌کننده‌ها، و نوشتن کوئری‌ها، جهش‌ها و احتمالاً اشتراک‌ها است. ابزارهایی مانند Back4app این فرآیند را با ایجاد خودکار یک طرح GraphQL بر اساس مدل‌های پایگاه داده ساده می‌کنند و تلاش دستی مربوط به توسعه API را به میزان قابل توجهی کاهش می‌دهند. این انتزاع نه تنها روند توسعه را تسریع می‌کند، بلکه تضمین می‌کند که توسعه‌دهندگان می‌توانند بر روی ساختن بخش مقدماتی و منطق تجاری برنامه‌های خود تمرکز کنند.
            </p><br>
            <p>GraphQL نشان دهنده تغییر قابل توجهی در نحوه طراحی و مصرف API ها است و رویکردی کارآمدتر، انعطاف پذیرتر و سازگارتر با توسعه دهندگان را ارائه می دهد. چه در حال شروع یک پروژه جدید باشید و چه به دنبال بهبود یک برنامه کاربردی موجود باشید، GraphQL مجموعه ابزار قدرتمندی برای ساخت APIهای پویا، مقیاس پذیر و کارآمد ارائه می دهد.</p>
            
        </section>
        <section>
            <h3>(gRPC) Google Remote Procedure Call<br>تماس رویه از راه دور (RPC) چیست؟
            </h3>
             <p>RPC یا  Remote Procedure Call یک ارتباط بین فرایندی است که در آن یک برنامه کامپیوتری رویه ای (عملکرد یا روش) را برای اجرا در فضای آدرسی متفاوت از فضای خود فراخوانی می کند. RPC این توهم را به کلاینت می دهد که یک متد محلی را فراخوانی می کند، اما در واقع، متدی را در یک ماشین راه دور فراخوانی می کند که وظایف لایه شبکه را انتزاع می کند. RPC از یک پروتکل درخواست-پاسخ (مدل کلاینت-سرور) پیروی می کند. شکل زیر چرخه عمر RPC را نشان می دهد.</p><br>
             <ul>پیاده سازی های مختلفی از RPC ها وجود دارد. آن ها هستند:

                <li> gRPC (Google)
                </li>
                <li>Thrift (فیس بوک)</li>
                <li>Finagle (توئیتر)</li>
             </ul>
             <p>شناخته شده ترین فریم ورکی که یک RPC می سازد gRPC است. gRPC مانند Docker و Kubernetes بخشی از Cloud Native Computing Foundation است. RPC مخفف فراخوانی روش از راه دور است.
            </p><br>
            <img src="images/4.19 photo.png" alt=""><br>
            <ol>
                <li>Unary RPC که در آن مشتری یک درخواست واحد را به سرور ارسال می کند و یک پاسخ را دریافت می کند.</li>
                <li>Server Stream RPC که در آن مشتری درخواستی را به سرور ارسال می کند و جریانی از پاسخ ها را دریافت می کند.</li>
                <li>Client Stream RPC که در آن مشتری یک سری پیام را به سرور ارسال می کند، که سپس یک پاسخ را برمی گرداند.</li>
                <li>Bidirectional RPC که در آن هر دو طرف جریانی از پیام ها را به یکدیگر ارسال می کنند.</li>

            </ol>
            <p>gRPC، مخفف Google Remote Procedure Call، یک پروتکل ارتباطی منبع باز است که توسط Google توسعه یافته است. این طراحی شده است تا ارتباط کارآمد و کم تأخیر بین خدمات در یک سیستم توزیع شده را امکان پذیر کند. gRPC از HTTP/2 برای انتقال، (Protocol Buffers (protobufs به عنوان زبان توصیف رابط خود استفاده می‌کند و ویژگی‌هایی مانند احراز هویت، تعادل بار و غیره را ارائه می‌دهد. این به ویژه برای معماری های میکروسرویس که در آن عملکرد و مقیاس پذیری بسیار مهم است، مناسب است</p><br>
            <img src="images/4.20 photo.png" alt="">
        </section>
        <section>
            <h3>اصول اصلی gRPC
            </h3><br>
            <p>بر اساس HTTP/2: gRPC از HTTP/2 برای انتقال استفاده می‌کند که امکان جریان‌های چندگانه را در یک اتصال واحد فراهم می‌کند. این امر منجر به کاهش تاخیر و افزایش کارایی در ارتباط بین سرویس ها می شود.

                بافرهای پروتکل: gRPC از بافرهای پروتکل استفاده می‌کند، یک مکانیسم خنثی برای زبان، خنثی از پلتفرم، و قابل توسعه برای سریال‌سازی داده‌های ساخت‌یافته. این انتخاب از نظر کارایی و سادگی نسبت به JSON یا XML که معمولاً در API های RESTful استفاده می شوند، مزایایی را ارائه می دهد.
                
                قراردادهای قوی تایپ شده: با gRPC، قراردادهای خدمات با استفاده از فایل های .proto تعریف می شوند. این یک سطح API با تایپ قوی را تضمین می کند که در آن ساختار داده ها و قابلیت های سرویس به وضوح مشخص شده است.
                </p><br>
                <ul>gRPC یک انتخاب ایده آل در سناریوهایی است که:
                    <li>تأخیر کم و توان عملیاتی بالا مورد نیاز است: استفاده از HTTP/2 و بافرهای پروتکل، gRPC را بسیار کارآمد و سریع می کند، که برای میکروسرویس هایی که به طور مکرر ارتباط برقرار می کنند یا حجم زیادی از داده را مدیریت می کنند، بسیار مهم است.
                    </li>
                    <li>سازگاری بین زبانی مورد نیاز است: gRPC از طیف گسترده ای از زبان های برنامه نویسی پشتیبانی می کند و ایجاد سیستم هایی متشکل از اجزای نوشته شده به زبان های مختلف را آسان می کند.
                    </li>
                    <li>قراردادهای سختگیرانه API مفید هستند: ماهیت قوی تایپ شده API های gRPC به تشخیص زودهنگام مشکلات کمک می کند و ارتباط واضح تر بین بخش های مختلف یک سیستم را تسهیل می کند.

                    </li>
                </ul>
                <ul>مزایای gRPC
                    <li>عملکرد: استفاده gRPC از HTTP/2 و بافرهای پروتکل منجر به بارهای کوچکتر و ارتباطات سریعتر می شود.
                    </li>
                    <li>قابلیت همکاری: پشتیبانی gRPC از زبان های برنامه نویسی متعدد، قابلیت همکاری را در یک اکوسیستم میکروسرویس ارتقا می دهد.
                    </li>
                    <li>پشتیبانی جریان: پشتیبانی درجه یک gRPC برای استریم برای ارتباطات بلادرنگ و انتقال داده های بزرگ ایده آل است.

                    </li>
                </ul>
                <ul>ملاحظات مربوط به gRPC
                    <li>پشتیبانی مرورگر: gRPC-Web، گونه‌ای از gRPC، به دلیل پشتیبانی محدود مرورگر از ویژگی‌های HTTP/2 مورد استفاده توسط gRPC، برای تعامل با برنامه‌های کاربردی وب مورد نیاز است.
                    </li>
                    <li>پیچیدگی عملیاتی: ماهیت باینری پیام‌های gRPC و استفاده از HTTP/2 ممکن است پیچیدگی‌های عملیاتی را ایجاد کند، مانند نیاز به ابزار خاصی برای اشکال‌زدایی و نظارت.
                    </li>
                    <li>منحنی یادگیری: پذیرش gRPC مستلزم آشنایی با بافرهای پروتکل و خود چارچوب gRPC است که ممکن است در مقایسه با APIهای JSON/REST منحنی یادگیری را ارائه دهد.</li>
                </ul>
        </section>
        <section>
            <h3>نمونه ای از سرویس gRPC
            </h3><br>
            <p>تعریف سرویس gRPC شامل مشخص کردن روش های سرویس و نوع درخواست و پاسخ آنها در یک فایل .proto است. در اینجا یک مثال ساده آورده شده است:
            </p><br>
            <img src="images/4.21 photo.png" alt=""><br>
            <img src="images/4.22 photo.png" alt=""><br>
            <p>این فایل .proto یک سرویس Greeter را با روش SayHello تعریف می‌کند و نشان می‌دهد که چگونه gRPC اجازه می‌دهد تا مشخصات API واضحی را ارائه دهد.

                gRPC یک رویکرد قوی و با کارایی بالا برای ساختن سیستم‌ها و ریزسرویس‌های توزیع‌شده ارائه می‌دهد که با تایپ قوی، رمزگذاری داده‌های کارآمد و پشتیبانی از زبان گسترده پشتیبانی می‌شود. در حالی که پیچیدگی‌های عملیاتی و یادگیری خاصی را به همراه دارد، مزایای آن از نظر عملکرد و مقیاس‌پذیری، آن را به انتخابی قانع‌کننده برای بسیاری از موارد استفاده می‌کند، به‌ویژه در مواردی که تأخیر کم و کارایی بالا در اولویت هستند. مانند هر تصمیم دیگری در زمینه فناوری، مناسب بودن gRPC باید در زمینه الزامات پروژه و قابلیت‌های زیرساختی خاص ارزیابی شود.
                </p>
        </section>
        <section>
            <h3>وب سوکت</h3><br>
            <img src="images/4.23 photo.png" alt=""><br>
            <p>WebSocket یک پروتکل ارتباطی است که کانال های ارتباطی تمام دوبلکس را از طریق یک اتصال TCP با عمر طولانی فراهم می کند. WebSocket که به عنوان بخشی از مشخصات HTML5 ایجاد شده است، مرورگرها و سرورها را قادر می سازد تا داده ها را بدون سربار و محدودیت های مرتبط با اتصالات HTTP سنتی مبادله کنند. این باعث می‌شود WebSocket مخصوصاً برای برنامه‌های بلادرنگی که به تأخیر کم نیاز دارند، مانند سیستم‌های چت زنده، بازی‌ها و پلتفرم‌های معاملات مالی، مناسب باشد.</p>
        </section>
        <section>
            <h3>ویژگی های اصلی WebSocket</h3><br>
            <p>ارتباطات Full-Duplex: بر خلاف HTTP، که در آن ارتباطات معمولاً توسط مشتری آغاز می شود، WebSocket به مشتری و سرور اجازه می دهد تا داده ها را به طور مستقل و همزمان ارسال کنند.
                Single Connection: هنگامی که یک اتصال WebSocket برقرار شد، باز می ماند و اجازه می دهد تا داده ها در همان اتصال به عقب و جلو ارسال شوند و تاخیر و سربار کاهش یابد.
                کارآمد: WebSocket نیاز به باز کردن و بستن مکرر اتصالات را برطرف می کند، همانطور که در مکانیسم های نظرسنجی HTTP معمول است، و آن را برای به روز رسانی داده های بلادرنگ کارآمدتر می کند.
                سازگاری: WebSocket برای کار بر روی پورت های وب استاندارد (80 و 443) طراحی شده است که به جلوگیری از مشکلات فایروال و پروکسی که می تواند بر پورت های غیر استاندارد تأثیر بگذارد کمک می کند.
                </p><br>
                <img src="images/4.24 photo.png" alt="">
        </section>
        <section>
            <h3>چه زمانی از WebSocket استفاده کنیم؟</h3><br>
            <p>WebSocket در سناریوهایی می درخشد که نیاز به به روز رسانی داده ها در زمان واقعی با حداقل تأخیر دارند، مانند:

                اعلان‌های زنده: به‌روزرسانی فوری کاربران با اعلان‌ها یا هشدارها.
                برنامه های مشترک: فعال کردن ویژگی های همکاری بلادرنگ در برنامه هایی مانند Google Docs.
                بازی آنلاین: ارائه تعامل بدون درز و زمان واقعی در بازی های چند نفره.
                برنامه های مالی: نمایش نمادهای سهام زنده، سیستم های معاملاتی و به روز رسانی داده های مالی.
                </p>
        </section>
        <section>
            <h3>مثالی از استفاده از WebSocket</h3><br>
            <p>ایجاد یک اتصال WebSocket ساده شامل اجرای سمت کلاینت و سمت سرور است. در اینجا یک مثال اساسی برای نشان دادن آمده است:</p><br>
            <h4>سمت مشتری (جاوا اسکریپت):</h4><br>
            <img src="images/4.25 photo.png" alt=""><br>
            <h4>سمت سرور (Node.js با کتابخانه ws):</h4><br>
            <img src="images/4.26 photo.png" alt="">
            <img src="images/4.27 photo.png" alt="">
            <p>این مثال یک اتصال WebSocket را نشان می دهد که در آن سرور به اتصالات و پیام های دریافتی گوش می دهد و مشتری و سرور می توانند برای یکدیگر پیام ارسال کنند.
            </p>
            <ul>مزایای WebSocket
                <li>تبادل داده در زمان واقعی: WebSocket مکانیزمی را برای جریان داده در زمان واقعی بین کلاینت ها و سرورها فراهم می کند.
                </li>
                <li>تأخیر کاهش یافته: با حفظ یک اتصال مداوم، WebSocket تأخیر درگیر در ارتباطات را به حداقل می رساند.
                </li>
                <li>استفاده کارآمد از منابع: اتصال تکی و طولانی مدت WebSocket نسبت به اتصالات HTTP که برای هر درخواست باز و بسته می شوند، کارآمدتر است.
                </li>
            </ul>
            <ul>ملاحظات برای WebSocket
                <li>پیچیدگی در مقیاس‌بندی: مدیریت تعداد زیادی از اتصالات باز WebSocket می‌تواند چالش‌هایی را در مقیاس‌بندی و مدیریت منابع ایجاد کند.
                </li>
                <li>ملاحظات امنیتی: پیاده سازی اتصالات WebSocket ایمن (wss://) بسیار مهم است، زیرا اتصالات پایدار می توانند اهدافی برای تهدیدات امنیتی باشند.
                </li>
                <li>مکانیسم‌های بازگشتی: برای محیط‌هایی که WebSocket پشتیبانی نمی‌شود، مکانیسم‌های بازگشتی مانند نظرسنجی طولانی همچنان ممکن است مورد نیاز باشد.
                </li>
            </ul>
            <p>WebSocket یک پروتکل قدرتمند برای ساخت برنامه های کاربردی وب تعاملی و بلادرنگ ارائه می دهد. توانایی آن در تسهیل ارتباطات تمام دوبلکس از طریق یک اتصال، آن را برای برنامه‌هایی که نیاز به به‌روزرسانی فوری داده و تعامل دارند، ایده‌آل می‌کند. در حالی که WebSocket مزایای قابل توجهی در عملکرد و کارایی دارد، همچنین نیازمند بررسی دقیق مسائل امنیتی، مقیاس پذیری و سازگاری است. با استفاده مناسب از WebSocket، توسعه دهندگان می توانند تجربیات کاربر بسیار پاسخگو و جذاب ایجاد کنند.</p>
        </section>
        <section>
            <h3>وب هوک</h3><br>
            <img src="images/4.28 photo.png" alt=""><br>
            <p>WebHooks تماس‌های HTTP تعریف‌شده توسط کاربر هستند که روشی سبک و کارآمد برای پیاده‌سازی ارتباط رویداد محور بین برنامه‌ها بر روی وب ارائه می‌کنند. اساساً، WebHooks به یک برنامه اجازه می‌دهد تا به‌جای اینکه سیستم دریافت‌کننده را به‌طور مداوم تغییرات را نظرسنجی کند، در زمان وقوع یک رویداد، به یک سیستم یا سرویس دیگر اطلاع دهد. این مکانیسم WebHooks را به ویژه برای سناریوهایی مفید می‌کند که در آن واکنش‌های به‌موقع به رویدادهای خاص، مانند اعلان‌های پرداخت، به‌روزرسانی‌های سرویس‌های شخص ثالث، یا ادغام با سایر برنامه‌های وب، حیاتی هستند.</p><br>
        </section>
        <section>
            <h3>ویژگی های اصلی WebHooks</h3><br>
            <p>رویداد محور: WebHok ها توسط رویدادهای خاصی مانند ثبت نام کاربر جدید، آپلود فایل یا تکمیل تراکنش فعال می شوند. هنگامی که رویداد تعریف شده رخ می دهد، WebHook یک درخواست HTTP را به یک URL پیکربندی شده ارسال می کند.
                ساده و انعطاف پذیر: پیاده سازی WebHooks فقط به توانایی رسیدگی به درخواست های HTTP و ارسال درخواست های HTTP POST نیاز دارد. این سادگی WebHooks را با موارد استفاده مختلف سازگار می کند.
                اعلان‌های بلادرنگ: WebHooks اعلان‌های تقریباً آنی در مورد رویدادها ارائه می‌کند و نیاز به مکانیسم‌های نظرسنجی با منابع فشرده را کاهش می‌دهد.
                خدمات جداشده: با تکیه بر WebHooks برای ارتباطات، سرویس‌ها می‌توانند به طور مستقل عمل کنند و اتصال محکم را کاهش دهند و ماژولار بودن را افزایش دهند.
                </p>
        </section>
        <section>
            <h3>چه زمانی از WebHooks استفاده کنیم؟
            </h3><br>
            <p>WebHooks در شرایطی که ارتباط به موقع و کارآمد بین سیستم ها یا خدمات متفاوت مورد نیاز است ایده آل هستند، از جمله:</p>
            <ul>
                <li>WebHooks در شرایطی که ارتباط به موقع و کارآمد بین سیستم ها یا خدمات متفاوت مورد نیاز است ایده آل هستند، از جمله:</li>
                <li>Automating Workflows: راه‌اندازی دنباله‌ای از اقدامات در سیستم‌های مختلف هنگام وقوع یک رویداد، مانند ارسال ایمیل، به‌روزرسانی پایگاه‌های داده یا شروع فرآیندهای ساخت.</li>
                <li>ایجاد اکوسیستم‌های مبتنی بر API: به توسعه‌دهندگان شخص ثالث امکان می‌دهد تا عملکرد یک پلتفرم یا سرویس را با اشتراک در رویدادهای خاص گسترش دهند.</li>

               
            </ul>
        </section>
        <section>
            <h3>مثالی از استفاده از WebHook</h3>
            <p>فروشگاه آنلاینی را در نظر بگیرید که هر زمان که فروش رخ می دهد نیاز به به روز رسانی سیستم مدیریت موجودی خارجی دارد. یک WebHook را می توان برای اطلاع رسانی به سیستم موجودی در زمان واقعی تنظیم کرد.
            </p>
            <ul>راه اندازی WebHook (شبه کد / Pseudo-code):
                <li>سیستم فروشگاه آنلاین امکان ثبت URL WebHook برای رویدادهای فروش را فراهم می کند.</li>
                <li>سیستم مدیریت موجودی یک URL (به عنوان مثال، https://inventory.example.com/webhook) برای دریافت اعلان ها ارائه می دهد.</li>
            </ul>
            <p>سمت فروشگاه اینترنتی:</p><br>
            <p>هنگامی که فروش کامل شد، سیستم فروشگاه یک درخواست HTTP POST به آدرس وب هوک سیستم موجودی با جزئیات مربوط به فروش ارسال می کند.</p>
            <img src="images/4.29 photo.png" alt=""><br>
            <p>سمت سیستم موجودی:
            </p><br>
            <p>سیستم موجودی به درخواست های HTTP POST دریافتی در نقطه پایانی /webhook گوش می دهد، جزئیات فروش را تجزیه می کند و موجودی را بر این اساس به روز می کند.
            </p>
            <ul>
                <li>مزایای WebHooks</li>
                <li>کارایی: WebHooks نیاز به نظرسنجی مداوم، کاهش ترافیک شبکه و بار سرور را از بین می برد.
                </li>
                <li>زمان واقعی: آنها اقدام فوری را در پاسخ به رویدادها فعال می کنند و برنامه های بلادرنگ را تسهیل می کنند.
                </li>
                <li>پیاده سازی ساده: WebHooks از روش های استاندارد HTTP استفاده می کند که پیاده سازی و درک آنها را آسان می کند.</li>
            </ul>
            <ul>
                <li>ملاحظاتی برای WebHooks</li>
                <li>امنیت: اطمینان از صحت و یکپارچگی درخواست های دریافتی WebHook بسیار مهم است. استراتژی های رایج شامل استفاده از نشانه های مخفی، HTTPS و اعتبارسنجی منابع درخواست است.</li>
                <li>مدیریت خطا: مدیریت خطاها برای مدیریت خرابی‌ها، مانند مشکلات شبکه یا خرابی سرور مقصد، ضروری است.
                </li>
                <li>مقیاس پذیری: مدیریت حجم زیادی از درخواست های WebHook می تواند چالش برانگیز باشد و به پردازش کارآمد و احتمالاً مکانیسم صف نیاز دارد.
                </li>
            </ul>
            <p>WebHooks یک راه ساده و موثر برای تسهیل ارتباطات بلادرنگ و رویداد محور بین سرویس های وب ارائه می دهد. با استفاده از WebHooks، توسعه‌دهندگان می‌توانند برنامه‌های تعاملی و پاسخ‌گوی بیشتری ایجاد کنند، گردش کار را خودکار کنند و به راحتی با خدمات شخص ثالث ادغام شوند. در حالی که سادگی و قابلیت های بلادرنگ WebHooks مزایای متعددی را به همراه دارد، توجه به ملاحظات امنیتی، مدیریت خطا و مقیاس پذیری برای اطمینان از اجرای قوی مهم است.</p>
        </section>
        <section>
            <h3>MQTT) Message Queuing Telemetry Transport)</h3><br>
            <img src="images/4.30 photo.png" alt=""><br>
            <p>MQTT که مخفف عبارت Message Queuing Telemetry Transport است، یک پروتکل پیام رسانی سبک است که برای شبکه های با پهنای باند کم، تأخیر بالا یا غیرقابل اعتماد طراحی شده است. MQTT که در اواخر دهه 1990 برای نظارت بر خطوط لوله نفت از طریق اتصالات ماهواره ای توسعه داده شد، به یک انتخاب محبوب برای برنامه های مختلف (Internet of Things (IoT تبدیل شده است که امکان ارتباط کارآمد و قابل اعتماد بین دستگاه ها را فراهم می کند.</p>
        </section>
        <section>
            <h3>ویژگی های اصلی MQTT
            </h3>
            <img src="images/4.31 photo.png" alt="">
            <ul>
                <li>ightweight Protocol: پروتکل MQTT برای به حداقل رساندن پهنای باند شبکه و منابع مورد نیاز دستگاه طراحی شده است و آن را برای دستگاه ها و شبکه های محدود ایده آل می کند.</li>
                <li>مدل انتشار/اشتراک - Publish/Subscribe Model: برخلاف مدل‌های سنتی مشتری-سرور، MQTT بر روی یک مکانیسم انتشار/اشتراک عمل می‌کند، که در آن کلاینت‌ها مشترک موضوعات هستند و زمانی که داده‌ها در مورد آن موضوعات منتشر می‌شود، پیام‌ها به همه مشترکین ارسال می‌شود.</li>
                <li>Quality of Service (QoS) Levels: پروتکل MQTT از سه سطح QoS برای مدیریت تضمین های تحویل پیام، از تحویل "حداکثر یک بار" تا "دقیقا یک بار" پشتیبانی می کند و نیازهای مختلف قابل اطمینان و تحویل را برآورده می کند.</li>
                <li>(Last Will and Testament (LWT: قابلیتی که به مشتریان اجازه می دهد در صورت قطع غیرمنتظره ارتباط، پیامی از پیش تعریف شده را به یک موضوع مشخص ارسال کنند که برای نظارت بر اتصال و وضعیت دستگاه مفید است.</li>
                <li>(Last Will and Testament (LWT: قابلیتی که به مشتریان اجازه می دهد در صورت قطع غیرمنتظره ارتباط، پیامی از پیش تعریف شده را به یک موضوع مشخص ارسال کنند که برای نظارت بر اتصال و وضعیت دستگاه مفید است.</li>
            </ul>
        </section>
        <section>
            <h3>چه زمانی از MQTT استفاده کنیم؟
            </h3>
            <p>MQTT به ویژه برای سناریوهایی مناسب است که کارایی شبکه، عمر باتری دستگاه و تحویل پیام قابل اعتماد بسیار مهم است، از جمله:</p>
            <ul>
                <li>ارتباطات IoT و M2M: اتصال تعداد زیادی از دستگاه های کم مصرف و پهنای باند کم در خانه های هوشمند، اینترنت اشیاء صنعتی و نظارت بر محیط زیست.</li>
                <li>به روز رسانی در زمان واقعی: ارائه اطلاعات به موقع در برنامه هایی مانند ردیابی خودرو، هشدارهای اضطراری و به روز رسانی زنده.</li>
                <li>نظارت و کنترل از راه دور: امکان نظارت و کنترل کارآمد و در زمان واقعی بر دستگاه ها و زیرساخت های راه دور.</li>

            </ul>
        </section>
        <section>
            <h3>مثالی از استفاده از MQTT</h3><br>
            <img src="images/4.32 photo.png" alt=""><br>
            <p>یک سناریوی خانه هوشمند را در نظر بگیرید که در آن حسگرهای مختلف داده‌ها (مانند دما، رطوبت) را برای یک کارگزار MQTT منتشر می‌کنند و یک سیستم اتوماسیون خانگی مشترک این موضوعات می‌شود تا به‌روزرسانی‌ها را دریافت کند و بر اساس آنها عمل کند.</p><br>
            <img src="images/4.33 photo.png" alt=""><br>
            <img src="images/4.33 photo.png" alt=""><br>
            <p>این مثال سنسوری را نشان می‌دهد که داده‌های دما را برای یک کارگزار MQTT و یک سیستم اتوماسیون خانگی مشترک برای دریافت این داده‌ها منتشر می‌کند و اقداماتی را بر اساس آخرین خوانش‌های دما انجام می‌دهد.</p>
            <ul>
                <li>مزایای MQTT
                </li>
                <li>کارایی: طراحی سبک MQTT به حداقل پهنای باند شبکه و منابع دستگاه نیاز دارد.</li>
                <li>قابلیت اطمینان: سطوح QoS پروتکل، تحویل پیام قابل اعتماد را حتی در شرایط شبکه ناپایدار تضمین می کند.</li>
                <li>مقیاس پذیری: MQTT می تواند هزاران دستگاه را از طریق یک کارگزار پشتیبانی کند و آن را برای استقرارهای بزرگ اینترنت اشیا مقیاس پذیر می کند.</li>
            </ul>
            <ul>
                <li>ملاحظات برای MQTT</li>
                <li>امنیت: در حالی که MQTT خود سبک وزن است، اجرای اقدامات امنیتی قوی (مانند رمزگذاری TLS/SSL، احراز هویت و مجوز) برای محافظت در برابر تهدیدات احتمالی بسیار مهم است.</li>
                <li>امنیت: در حالی که MQTT خود سبک وزن است، اجرای اقدامات امنیتی قوی (مانند رمزگذاری TLS/SSL، احراز هویت و مجوز) برای محافظت در برابر تهدیدات احتمالی بسیار مهم است.</li>
                <li>پیچیدگی در استقرار در مقیاس بزرگ: مدیریت تعداد زیادی از موضوعات و اشتراک ها در استقرار IoT در مقیاس بزرگ می تواند پیچیده شود و به قراردادهای نامگذاری موضوعات و برنامه ریزی معماری کارآمد نیاز دارد.</li>

            </ul>
            <p>MQTT به عنوان یک پروتکل پیام رسانی قوی و کارآمد برای ارتباطات IoT و M2M متمایز است که ویژگی‌هایی را ارائه می‌کند که برای محیط‌های با پهنای باند کم، تأخیر بالا و تضمین تحویل پیام قابل اعتماد طراحی شده است. سادگی آن، همراه با قابلیت‌های قدرتمندی مانند مدل انتشار/اشتراک و سطوح QoS، MQTT را به انتخابی ارجح برای توسعه‌دهندگانی که برنامه‌های کاربردی اینترنت اشیا متصل، پاسخگو و مقیاس‌پذیر می‌سازند، تبدیل می‌کند. مانند هر پروتکل ارتباطی، پرداختن به ملاحظات امنیتی و مقیاس‌پذیری کلید استقرار راه‌حل‌های موفق مبتنی بر MQTT است.</p>

        </section>
        <section>
            <h3>AMQP) Advanced Message Queuing Protocol)</h3><br>
            <img src="images/4.34 photo.png" alt=""><br>
            <p>AMQP یا Advanced Message Queuing Protocol یک استاندارد باز برای ارسال پیام بین برنامه ها یا سازمان ها با قابلیت اطمینان و قابلیت همکاری بالا است. بر خلاف MQTT که عمدتاً برای ارتباط دستگاه به دستگاه با کمترین هزینه سربار طراحی شده است، AMQP بر کارگزاری پیام پیچیده و تضمین هایی مانند تحویل پیام، سفارش و مسیریابی تمرکز دارد. AMQP که در ابتدا برای بخش مالی توسعه یافته بود، کاربرد خود را در حوزه های مختلفی که به راه حل های پیام رسانی قوی نیاز دارند، از جمله سیستم های فناوری اطلاعات سازمانی، محاسبات ابری و اینترنت اشیا در مواقعی که الگوهای پیام رسانی پیچیده لازم است، گسترش داده است.</p>

        </section>
        <section>
            <h3>ویژگی های اصلی AMQP</h3>
            <ul>
                <li>قابلیت اطمینان و امنیت: AMQP مکانیزم‌های داخلی را برای دوام پیام، تأیید، تراکنش‌ها و احراز هویت و رمزگذاری امن ارائه می‌کند.</li>
                <li>مدل‌های پیام‌رسانی انعطاف‌پذیر: از مدل‌های پیام‌رسان نقطه به نقطه و انتشار/اشتراک پشتیبانی می‌کند و طیف وسیعی از موارد استفاده را ارائه می‌دهد.</li>
                <li>قابلیت همکاری: AMQP که با در نظر گرفتن قابلیت همکاری طراحی شده است، رفتار کارگزار پیام و مشتری را الزامی می کند و از رفتار سازگار در بین پیاده سازی های مختلف اطمینان می دهد.</li>
                <li>قابلیت همکاری: AMQP که با در نظر گرفتن قابلیت همکاری طراحی شده است، رفتار کارگزار پیام و مشتری را الزامی می کند و از رفتار سازگار در بین پیاده سازی های مختلف اطمینان می دهد.</li>
            </ul>
        </section>
        <section>
            <h3>چه زمانی از AMQP استفاده کنیم؟</h3><br>
            <p>AMQP به ویژه برای برنامه هایی مناسب است که در آنها:</p>
            <ul>
                <li>AMQP به ویژه برای برنامه هایی مناسب است که در آنها:</li>
                <li>الگوهای مسیریابی و پیام رسانی پیچیده برای پیاده سازی منطق تجاری و گردش کار پیچیده مورد نیاز است.</li>
                <li>قابلیت همکاری در میان سیستم‌های مختلف مورد نیاز است، که به اجزا و سرویس‌های مختلف، که احتمالاً به زبان‌های مختلف نوشته شده‌اند یا بر روی پلت‌فرم‌های مختلف اجرا می‌شوند، اجازه می‌دهد تا با اطمینان ارتباط برقرار کنند.</li>

            </ul>
        </section>
        <section>
            <h3>نمونه ای از استفاده از AMQP
            </h3><br>
            <p>یک پلتفرم تجارت الکترونیک را در نظر بگیرید که از AMQP برای پردازش سفارش استفاده می کند. این پلتفرم پیام‌هایی را در مورد سفارش‌های جدید به یک صف ارسال می‌کند که از آنجا چندین سرویس پیام‌ها را برای پردازش پرداخت‌ها، به‌روزرسانی موجودی و رسیدگی به حمل و نقل مصرف می‌کنند.</p>
            <img src="images/4.35 photo.png" alt=""><br>
            <img src="images/4.36 photo.png" alt=""><br>
            <img src="images/4.37 photo.png" alt=""><br>
            <p>این مثال نشان می‌دهد که چگونه یک پیام سفارش در یک صف AMQP منتشر می‌شود و چگونه یک مصرف‌کننده پیام‌ها را از صف پردازش می‌کند و ارتباط جداشده و قابل اعتماد بین بخش‌های مختلف سیستم را امکان‌پذیر می‌سازد.
            </p>
            <ul>
                <li>مزایای AMQP</li>
                <li>استحکام: تمرکز AMQP بر تحویل پیام و تراکنش‌های قابل اطمینان تضمین می‌کند که پیام‌ها از بین نمی‌روند و آن را برای فرآیندهای تجاری حیاتی ایده‌آل می‌کند.
                </li>
                <li>تطبیق پذیری: پشتیبانی آن از طیف گسترده ای از الگوهای پیام رسانی و گزینه های مسیریابی، انعطاف پذیری را در طراحی برنامه های کاربردی پیچیده فراهم می کند.
                </li>
                <li>قابلیت همکاری: استانداردسازی پروتکل تضمین می کند که پیاده سازی های مختلف AMQP می توانند به طور یکپارچه با هم کار کنند.
                </li>
                <li>قابلیت همکاری: استانداردسازی پروتکل تضمین می کند که پیاده سازی های مختلف AMQP می توانند به طور یکپارچه با هم کار کنند.
                </li>
                <li>پیچیدگی: ویژگی‌ها و قابلیت‌های گسترده AMQP می‌تواند پیچیدگی را در اجرا و عملیات ایجاد کند، به‌ویژه برای موارد استفاده ساده که پروتکل‌های سبک وزن ممکن است کافی باشد.
                </li>
                <li>عملکرد: در حالی که بسیار قابل اعتماد است، سربار اضافی مورد نیاز برای ویژگی های AMQP ممکن است بر عملکرد تأثیر بگذارد، به ویژه در سناریوهایی که تأخیر یک نگرانی اساسی است.
                </li>
                <li>وابستگی کارگزار: انتخاب واسطه پیام و پیکربندی آن می تواند به طور قابل توجهی بر عملکرد و قابلیت اطمینان سیستم های مبتنی بر AMQP تأثیر بگذارد.
                </li>
            </ul>
            <p>AMQP یک راه حل جامع برای پیام رسانی در سطح سازمانی ارائه می دهد که تحویل تضمینی، مسیریابی پیچیده و قابلیت همکاری بین سیستم های مختلف را ارائه می دهد. استحکام و انعطاف پذیری آن را به گزینه ای عالی برای کاربردهای پیچیده ای که نیاز به ارتباط قابل اعتماد دارند تبدیل می کند. با این حال، ملاحظات پیچیدگی و عملکرد به این معنی است که AMQP برای سناریوهایی که ویژگی‌های پیشرفته آن یک ضرورت هستند به جای برنامه‌های ساده‌تر و حساس به تأخیر، مناسب‌تر است. درک الزامات خاص برنامه شما شما را در انتخاب AMQP یا یک پروتکل پیام رسانی جایگزین راهنمایی می کند.</p>

        </section>
        <section>
            <h3>انتخاب معماری بهینه API
            </h3><br>
            <p>انتخاب معماری API مناسب یک تصمیم حیاتی است که بر عملکرد، امنیت و مقیاس پذیری برنامه تأثیر می گذارد. هر سبک معماری نقاط قوت خود را دارد و برای موارد استفاده خاص مناسب است:</p>
            <ul>
                <li>برای امنیت دقیق و یکپارچگی تراکنش: SOAP بهترین انتخاب است.</li>
                <li>هنگامی که سادگی و مقیاس پذیری کلیدی است: REST یک راه حل کارآمد ارائه می دهد.
                </li>
                <li>برای بهینه سازی بازیابی داده ها در چندین منبع: GraphQL انعطاف پذیری بی نظیری را ارائه می دهد.
                </li>
                <li>برای ارتباطات با کارایی بالا در میکروسرویس ها: gRPC بی همتا است.
                </li>
                <li>WebSocket در سناریوهایی که نیاز به به روز رسانی در زمان واقعی دارند برتر است، در حالی که WebHooks مکانیسم های اعلان رویداد ساده را ارائه می دهد. </li>
                <li>WebSocket در سناریوهایی که نیاز به به روز رسانی در زمان واقعی دارند برتر است، در حالی که WebHooks مکانیسم های اعلان رویداد ساده را ارائه می دهد. </li>
                <li>AMQP با مجموعه ویژگی های قوی خود نیازهای پیچیده پیام رسانی را برآورده می کند.</li>
            </ul>
            <p>درک نیازهای خاص برنامه شما در انتخاب مناسب ترین معماری API بسیار مهم است. خواه قابلیت‌های بلادرنگ WebSocket، دقت GraphQL یا قابلیت اطمینان AMQP باشد، انتخاب درست به اهداف برنامه و چالش‌هایی که می‌خواهد بر آن غلبه کند بستگی دارد.</p>
        </section>
      </section>
    </main>
  </body>
</html>
